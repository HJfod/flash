use clang::{Entity, EntityKind};
use std::{
    collections::{HashMap, HashSet},
    fs,
    path::{Path, PathBuf},
    process::Command,
};
use strfmt::strfmt;

use crate::{
    cmake,
    config::{Config, Mode},
};

struct Builder<'a> {
    pub config: &'a Config,
    pub already_built: HashSet<String>,
}

impl<'a> Builder<'a> {
    pub fn new(config: &'a Config) -> Self {
        Self {
            config,
            already_built: HashSet::new(),
        }
    }
}

fn run_command(cmd: &String) -> Result<(), String> {
    let args =
        shlex::split(cmd).unwrap_or_else(|| panic!("Unable to parse prebuild command `{cmd}`"));
    let exit = Command::new(&args[0])
        .args(&args[1..])
        .spawn()
        .map_err(|e| format!("Unable to execute prebuild command `{cmd}`: {e}"))?
        .wait()
        .unwrap();
    if exit.success() {
        Ok(())
    } else {
        Err(format!("Prebuild command `{cmd}` failed"))
    }
}

fn fmt_link(config: &Config, url: &str, text: &str) -> String {
    strfmt(
        &config.link_template,
        &HashMap::from([("url".to_string(), url), ("text".to_string(), text)]),
    )
    .unwrap()
}

fn create_analyzable_file(config: &Config, output_dir: &Path) -> Result<PathBuf, String> {
    let out_path = output_dir.join("_analyze.cpp");

    let mut data = String::from(
        "// File generated by Flash for including all headers in order to\n\
        // parse them\n",
    );
    for hdr in &config.headers {
        data += &format!(
            "#include \"{}\"\n",
            hdr.canonicalize().unwrap().to_str().unwrap()
        );
    }
    fs::write(&out_path, data)
        .map_err(|e| format!("Unable to create source file for parsing headers: {e}"))?;

    Ok(out_path)
}

fn build_docs_recurse(
    builder: &mut Builder,
    entity: Entity,
    namespace: &Path,
) -> Result<(), String> {
    for entity in entity.get_children() {
        if entity.is_in_system_header() {
            continue;
        }
        // println!(
        //     "Building docs for {}",
        //     entity.get_display_name().unwrap_or("<Anonymous>".into())
        // );
        let source_link;
        let header_link;
        if let Some(ref tree) = builder.config.tree {
            let src_url = format!(
                "{}/{}",
                tree,
                entity
                    .get_file()
                    .map(|f| f.get_path().to_str().unwrap().to_owned())
                    .unwrap_or("none".into())
            );
            let hdr_url = format!(
                "{}/{}",
                tree,
                entity
                    .get_canonical_entity()
                    .get_file()
                    .map(|f| f.get_path().to_str().unwrap().to_owned())
                    .unwrap_or("none".into())
            );

            header_link = fmt_link(builder.config, &hdr_url, "View Header").into();
            source_link = fmt_link(builder.config, &src_url, "View Source").into();
        } else {
            source_link = None;
            header_link = None;
        }

        match entity.get_kind() {
            EntityKind::Namespace => {
                build_docs_recurse(
                    builder,
                    entity,
                    &namespace.join(entity.get_name().unwrap_or("_anon_ns".into())),
                )?;
            }
            EntityKind::StructDecl | EntityKind::ClassDecl => {
                if !entity.is_definition() {
                    continue;
                }
                let Some(name) = entity.get_name() else {
                    continue;
                };
                builder.already_built.insert(name.clone());
                let target_path = namespace.join(name + ".html");
                if target_path.exists() {
                    continue;
                }

                let vars = HashMap::from([
                    ("name".to_string(), entity.get_name().unwrap()),
                    (
                        "description".into(),
                        entity
                            .get_parsed_comment()
                            .map(|c| c.as_html())
                            .unwrap_or("<p>No Description Provided</p>".into()),
                    ),
                    ("source_link".into(), source_link.unwrap_or("".into())),
                    ("header_link".into(), header_link.unwrap_or("".into())),
                ]);

                let data = strfmt(&builder.config.class_template, &vars)
                    .map_err(|e| format!("Unable to format class template: {e}"))?;

                fs::create_dir_all(target_path.parent().unwrap()).unwrap();
                fs::write(&target_path, data).unwrap();
            }
            _ => {}
        }
    }

    Ok(())
}

fn build_docs_with_cmake(config: &Config, output_dir: &Path) -> Result<(), String> {
    // Configure the cmake project
    cmake::cmake_configure(config.cmake_config_args.as_ref().unwrap_or(&Vec::new()))?;

    // Build the cmake project
    if config.cmake_build {
        cmake::cmake_build(config.cmake_build_args.as_ref().unwrap_or(&Vec::new()))?;
    }

    // Initialize clang
    let clang = clang::Clang::new()?;
    let index = clang::Index::new(&clang, false, true);

    // Create a single source file that includes all headers
    let target_src = create_analyzable_file(config, output_dir)?;

    println!("Parsing {}", target_src.to_str().unwrap());

    let list = cmake::cmake_compile_args_for(config)
        .expect("Unable to infer CMake compile args");

    println!("args: {:?}", list);

    // Create parser
    let unit = index
        .parser(&target_src)
        .arguments(
            &list,
        )
        .parse()?;

    // Build the doc files
    let mut builder = Builder::new(config);
    build_docs_recurse(&mut builder, unit.get_entity(), output_dir)?;

    Ok(())
}

pub fn build_docs_for(config: &Config, output_dir: &Path) -> Result<(), String> {
    // Execute prebuild commands
    if let Some(ref cmds) = config.prebuild {
        for cmd in cmds {
            run_command(cmd)?;
        }
    }

    // Build based on mode
    match config.mode {
        Mode::CMake => build_docs_with_cmake(config, output_dir),
    }
}
