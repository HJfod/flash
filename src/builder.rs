use clang::{Entity, EntityKind};
use indicatif::{ProgressStyle, ProgressBar};
use std::{
    collections::HashMap,
    fs,
    path::{Path, PathBuf},
    process::Command, time::Duration,
};
use strfmt::strfmt;

use crate::{cmake, config::Config};

struct Page<'e> {
    pub url: String,
    pub entity: Entity<'e>,
}

struct Builder<'a, 'e> {
    pub config: &'a Config,
    pub index: HashMap<String, Page<'e>>,
}

impl<'a> Builder<'a, '_> {
    pub fn new(config: &'a Config) -> Self {
        Self {
            config,
            index: HashMap::new(),
        }
    }
}

fn run_command(cmd: &String) -> Result<(), String> {
    let args =
        shlex::split(cmd).unwrap_or_else(|| panic!("Unable to parse prebuild command `{cmd}`"));
    let exit = Command::new(&args[0])
        .args(&args[1..])
        .spawn()
        .map_err(|e| format!("Unable to execute prebuild command `{cmd}`: {e}"))?
        .wait()
        .unwrap();
    if exit.success() {
        Ok(())
    } else {
        Err(format!("Prebuild command `{cmd}` failed"))
    }
}

fn create_analyzable_file(config: &Config) -> Result<PathBuf, String> {
    let out_path = config.output_dir.join("_analyze.cpp");

    let mut data = String::from(
        "// File generated by Flash for including all headers in order to\n\
        // parse them\n",
    );
    for hdr in &config.filtered_includes() {
        data += &format!("#include <{}>\n", hdr.to_str().unwrap());
    }
    fs::write(&out_path, data)
        .map_err(|e| format!("Unable to create source file for parsing headers: {e}"))?;

    Ok(out_path)
}

fn get_fully_qualified_name(entity: &Entity) -> Vec<String> {
    let mut name = Vec::new();
    if let Some(parent) = entity.get_semantic_parent() {
        if !matches!(parent.get_kind(), EntityKind::TranslationUnit) {
            name.extend(get_fully_qualified_name(&parent));
        }
    }
    name.push(entity.get_name().unwrap_or("_anon".into()));
    name
}

fn get_header_url(config: &Config, entity: &Entity) -> Option<String> {
    Some(
        config.docs.tree.clone()? + &entity.get_file()?.get_path().to_str()?.replace("\\", "/")
    )
}

fn build_class_docs<'e>(
    builder: &mut Builder<'_, 'e>,
    entity: Entity<'e>,
    nest_dir: &Path
) -> Result<(), String> {
    // Skip anonymous
    let Some(name) = entity.get_name() else {
        return Ok(());
    };
    let full_name = get_fully_qualified_name(&entity);

    // Target directory
    let dir_path = nest_dir.join(name);

    // index.html location
    let index_html_path = builder.config.output_dir.join(&dir_path).join("index.html");

    builder.index.insert(
        full_name.join("::"),
        Page {
            // Convert dir path to relative URL
            url: String::from("./") + &dir_path.to_str().unwrap().replace("\\", "/"),
            entity: entity.clone()
        }
    );

    let vars = HashMap::from([
        ("name".to_string(), entity.get_name().unwrap()),
        (
            "description".into(),
            entity
                .get_parsed_comment()
                .map(|c| c.as_html())
                .unwrap_or("<p>No Description Provided</p>".into()),
        ),
        (
            "header_link".into(),
            get_header_url(builder.config, &entity)
                .map(|url| format!("<a href='{}'>View Header</a>", url))
                .unwrap_or(String::new())
        ),
    ]);

    let data = strfmt(&builder.config.presentation.class_template, &vars)
        .map_err(|e| format!("Unable to format class template: {e}"))?;

    fs::create_dir_all(index_html_path.parent().unwrap()).unwrap();
    fs::write(&index_html_path, data).unwrap();
    
    Ok(())
}

fn build_docs_recurse<'e>(
    builder: &mut Builder<'_, 'e>,
    entity: Entity<'e>,
    nest_dir: &Path,
    pbar: Option<&ProgressBar>,
) -> Result<(), String> {
    let children = entity.get_children();
    let mut i = 0f64;
    let len = children.len() as f64;
    for entity in children {
        if let Some(pbar) = pbar {
            pbar.set_position(
                (i / len * pbar.length().unwrap_or(1) as f64) as u64
            );
        }
        i += 1f64;
        if entity.is_in_system_header() {
            continue;
        }
        match entity.get_kind() {
            EntityKind::Namespace => {
                build_docs_recurse(
                    builder,
                    entity,
                    &nest_dir.join(entity.get_name().unwrap_or("_anon_ns".into())),
                    None,
                )?;
            }
            EntityKind::StructDecl | EntityKind::ClassDecl => {
                build_class_docs(builder, entity, nest_dir)?;
            }
            _ => {}
        }
    }

    Ok(())
}

fn build_index_page(
    builder: &Builder,
    output_dir: &Path,
) -> Result<(), String> {
    let vars = HashMap::from([
        ("project_name".to_string(), builder.config.project.name.clone()),
        (
            "links".into(),
            builder.index
                .iter()
                .map(|item| {
                    format!(
                        "<div>\n\
                            <p>{}</p>\n\
                            <a href='{}'>View Page</a>\n\
                        </div>",
                        item.0, item.1.url
                    )
                })
                .collect::<Vec<_>>()
                .join("\n")
        ),
    ]);

    let data = strfmt(&builder.config.presentation.index_template, &vars)
        .map_err(|e| format!("Unable to format index template: {e}"))?;

    fs::write(output_dir.join("index.html"), data).unwrap();

    Ok(())
}

fn build_docs_with_cmake(config: &Config) -> Result<(), String> {
    // Configure the cmake project
    cmake::cmake_configure(
        config
            .cmake
            .as_ref()
            .unwrap()
            .config_args
            .as_ref()
            .unwrap_or(&Vec::new()),
    )?;

    // Build the cmake project
    if config.cmake.as_ref().unwrap().build {
        cmake::cmake_build(
            config
                .cmake
                .as_ref()
                .unwrap()
                .build_args
                .as_ref()
                .unwrap_or(&Vec::new()),
        )?;
    }

    // Initialize clang
    let clang = clang::Clang::new()?;
    let index = clang::Index::new(&clang, false, true);

    // Create a single source file that includes all headers
    let target_src = create_analyzable_file(config)?;

    let pbar = ProgressBar::new_spinner();
    pbar.set_style(
        ProgressStyle::with_template("{msg:>15} {spinner} [{elapsed_precise}] [{bar}]")
        .unwrap()
    );
    pbar.set_message("Analyzing");
    pbar.enable_steady_tick(Duration::from_millis(200));

    // Create parser
    let unit = index
        .parser(&target_src)
        .arguments(
            &cmake::cmake_compile_args_for(config).expect("Unable to infer CMake compile args"),
        )
        .parse()?;

    pbar.set_length(25);
    pbar.set_message("Building docs");
    pbar.tick();

    // Build the doc files
    let mut builder = Builder::new(config);
    build_docs_recurse(&mut builder, unit.get_entity(), &PathBuf::from(""), Some(&pbar))?;

    pbar.set_message("Building index");

    build_index_page(&builder, &config.output_dir)?;

    pbar.set_message("Cleaning up files");

    // Clean up analyzable file
    fs::remove_file(target_src).unwrap();

    pbar.finish_using_style();

    Ok(())
}

pub fn build_docs_for(config: &Config) -> Result<(), String> {
    // Execute prebuild commands
    if let Some(cmds) = config.run.as_ref().and_then(|c| c.prebuild.as_ref()) {
        for cmd in cmds {
            run_command(cmd)?;
        }
    }

    // Build based on mode
    if config.cmake.is_some() {
        build_docs_with_cmake(config)
    } else {
        todo!("Impl plain config")
    }
}
