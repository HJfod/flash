
use indicatif::{ProgressBar, ProgressStyle};
use std::{fs, path::PathBuf, process::Command, time::Duration};
use crate::{cmake, config::Config, builder::{Builder, get_css_path}};

fn run_command(cmd: &String) -> Result<(), String> {
    let args =
        shlex::split(cmd).unwrap_or_else(|| panic!("Unable to parse prebuild command `{cmd}`"));
    let exit = Command::new(&args[0])
        .args(&args[1..])
        .spawn()
        .map_err(|e| format!("Unable to execute prebuild command `{cmd}`: {e}"))?
        .wait()
        .unwrap();
    if exit.success() {
        Ok(())
    } else {
        Err(format!("Prebuild command `{cmd}` failed"))
    }
}

fn setup_output(config: &Config) -> Result<(), String> {
    fs::write(get_css_path(config), &config.presentation.css).unwrap();
    Ok(())
}

fn create_analyzable_file(config: &Config) -> Result<PathBuf, String> {
    let out_path = config.output_dir.join("_analyze.cpp");

    let mut data = String::from(
        "// File generated by Flash for including all headers in order to\n\
        // parse them\n",
    );
    for hdr in &config.filtered_includes() {
        data += &format!("#include <{}>\n", hdr.to_str().unwrap());
    }
    fs::write(&out_path, data)
        .map_err(|e| format!("Unable to create source file for parsing headers: {e}"))?;

    Ok(out_path)
}

fn analyze_with_clang(config: &Config, args: &Vec<String>) -> Result<(), String> {
    // Initialize clang
    let clang = clang::Clang::new()?;
    let index = clang::Index::new(&clang, false, true);

    // Create a single source file that includes all headers
    let target_src = create_analyzable_file(config)?;

    let pbar = ProgressBar::new_spinner();
    pbar.set_style(
        ProgressStyle::with_template("{msg:>15} {spinner} [{elapsed_precise}] [{bar}]").unwrap(),
    );
    pbar.set_message("Analyzing");
    pbar.enable_steady_tick(Duration::from_millis(200));

    // Create parser
    let unit = index.parser(&target_src).arguments(args).parse()?;

    pbar.set_length(20);
    pbar.tick();

    // Build the navbar first
    pbar.set_message("Setting up");
    let mut builder = Builder::new(config, unit.get_entity());
    
    // Build the doc files
    pbar.set_message("Building docs");
    builder.build(Some(&pbar))?;

    pbar.set_message("Cleaning up files");

    // Clean up analyzable file
    fs::remove_file(target_src).unwrap();

    pbar.finish_using_style();

    Ok(())
}

fn analyze_with_cmake(config: &Config) -> Result<(), String> {
    // Configure the cmake project
    cmake::cmake_configure(
        config
            .cmake
            .as_ref()
            .unwrap()
            .config_args
            .as_ref()
            .unwrap_or(&Vec::new()),
    )?;

    // Build the cmake project
    if config.cmake.as_ref().unwrap().build {
        cmake::cmake_build(
            config
                .cmake
                .as_ref()
                .unwrap()
                .build_args
                .as_ref()
                .unwrap_or(&Vec::new()),
        )?;
    }

    analyze_with_clang(
        config,
        &cmake::cmake_compile_args_for(config).expect("Unable to infer CMake compile args"),
    )?;

    Ok(())
}

pub fn create_docs(config: &Config) -> Result<(), String> {
    // Execute prebuild commands
    if let Some(cmds) = config.run.as_ref().and_then(|c| c.prebuild.as_ref()) {
        for cmd in cmds {
            run_command(cmd)?;
        }
    }

    // Setup output directory
    setup_output(config)?;

    // Build based on mode
    if config.cmake.is_some() {
        analyze_with_cmake(config)
    }
    // Build with extra compile args only
    else {
        analyze_with_clang(config, &config.analysis.compile_args)
    }
}
