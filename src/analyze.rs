use crate::{builder::builder::Builder, cmake, config::Config};
use indicatif::{ProgressBar, ProgressStyle};
use std::{fs, path::PathBuf, process::Command, sync::Arc, time::Duration};

fn run_command(cmd: &String) -> Result<(), String> {
    let args =
        shlex::split(cmd).unwrap_or_else(|| panic!("Unable to parse prebuild command `{cmd}`"));
    let exit = Command::new(&args[0])
        .args(&args[1..])
        .spawn()
        .map_err(|e| format!("Unable to execute prebuild command `{cmd}`: {e}"))?
        .wait()
        .unwrap();
    if exit.success() {
        Ok(())
    } else {
        Err(format!("Prebuild command `{cmd}` failed"))
    }
}

fn create_analyzable_file(config: Arc<Config>) -> Result<PathBuf, String> {
    let out_path = config.output_dir.join("_analyze.cpp");

    let mut data = String::from(
        "// File generated by Flash for including all headers in order to\n\
        // parse them\n",
    );
    for hdr in &config.filtered_includes() {
        data += &format!("#include <{}>\n", hdr.to_str().unwrap());
    }
    fs::write(&out_path, data)
        .map_err(|e| format!("Unable to create source file for parsing headers: {e}"))?;

    Ok(out_path)
}

async fn analyze_with_clang(config: Arc<Config>, args: &Vec<String>) -> Result<(), String> {
    // Initialize clang
    let clang = clang::Clang::new()?;
    let index = clang::Index::new(&clang, false, true);

    // Create a single source file that includes all headers
    let target_src = create_analyzable_file(config.clone())?;

    let pbar = Arc::from(ProgressBar::new_spinner());
    pbar.set_style(
        ProgressStyle::with_template("{msg:>15} {spinner} [{elapsed_precise}]").unwrap(),
    );
    pbar.set_message("Analyzing");
    pbar.enable_steady_tick(Duration::from_millis(150));

    // Create parser
    let unit = index.parser(&target_src).arguments(args).parse()?;

    // Build the navbar first
    pbar.set_message("Setting up");
    let builder = Builder::new(config, unit.get_entity())?;

    // Build the doc files
    pbar.set_message("Building docs");
    builder.build(Some(pbar.clone())).await?;

    pbar.set_message("Cleaning up files");

    // Clean up analyzable file
    fs::remove_file(target_src).unwrap();

    pbar.finish_using_style();

    Ok(())
}

async fn analyze_with_cmake(config: Arc<Config>) -> Result<(), String> {
    // Configure the cmake project
    cmake::cmake_configure(
        config
            .cmake
            .as_ref()
            .unwrap()
            .config_args
            .as_ref()
            .unwrap_or(&Vec::new()),
    )?;

    // Build the cmake project
    if config.cmake.as_ref().unwrap().build {
        cmake::cmake_build(
            config
                .cmake
                .as_ref()
                .unwrap()
                .build_args
                .as_ref()
                .unwrap_or(&Vec::new()),
        )?;
    }

    analyze_with_clang(
        config.clone(),
        &cmake::cmake_compile_args_for(config).expect("Unable to infer CMake compile args"),
    )
    .await?;

    Ok(())
}

pub async fn create_docs(config: Arc<Config>) -> Result<(), String> {
    // Execute prebuild commands
    if let Some(cmds) = config.run.as_ref().and_then(|c| c.prebuild.as_ref()) {
        for cmd in cmds {
            run_command(cmd)?;
        }
    }

    // Build based on mode
    if config.cmake.is_some() {
        analyze_with_cmake(config).await
    }
    // Build with extra compile args only
    else {
        analyze_with_clang(config.clone(), &config.analysis.compile_args).await
    }
}
